<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Poignant Code]]></title>
  <link href="http://SeanMarcia.github.io/atom.xml" rel="self"/>
  <link href="http://SeanMarcia.github.io/"/>
  <updated>2014-07-25T19:11:25-04:00</updated>
  <id>http://SeanMarcia.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Refactoring towards Celluloid]]></title>
    <link href="http://SeanMarcia.github.io/blog/2014/07/21/refactoring/"/>
    <updated>2014-07-21T00:12:00-04:00</updated>
    <id>http://SeanMarcia.github.io/blog/2014/07/21/refactoring</id>
    <content type="html"><![CDATA[<p>(note: this blog post is work in progress, I figure since it was getting excessively long I would post what I have.)</p>

<h3 id="broken-gets-fixed-but-crap-lasts-forever">“Broken gets fixed but crap lasts forever.”</h3>

<p>We had a request a couple years ago for an automated link checker for all the sites in our system so our users would know when content they are linking to was no longer available. While tasks like this are important everywhere, in the academic setting, where I work, this is extremely important as our researchers and professors academic rankings depends on accurate and reviewable information.</p>

<p>I quickly hacked out a horrible solution that worked, put it into a cron job and then promised myself I’d come back and refactor when I had more time.</p>

<p>We’ve recently began to gamify the back end of our site to encourage user engagement and one of the metrics we’re using is the number of broken links. This required a refactoring of the task and a speeding up of it. This is something that is only run in a cron job once a month so the fact that it took 40 or so minutes wasn’t really an issue. We wanted to be able to speed this up so we could run it multiple times a day or hour if we wanted to.</p>

<!-- more -->

<p>So here’s the (ugly) code:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">@emaillist = {}
</span><span class="line">@events = Event.all
</span><span class="line">@articles = Article.all
</span><span class="line">@resources = Resource.all
</span><span class="line">@logfile = File.open("bad_link_log.txt","w")
</span><span class="line">
</span><span class="line">def organize_url(url, originating_site_domain)
</span><span class="line">  url.insert(0, originating_site_domain) if url.match(/^\//)
</span><span class="line">  url.insert(0, "http://") unless ((url.match(/^http\:\/\//)) or (url.match(/^https\:\/\//)))
</span><span class="line">  url = URI.encode(url) if (url =~ URI::DEFAULT_PARSER.regexp[:ABS_URI]).nil?
</span><span class="line">  return url
</span><span class="line">end
</span><span class="line">
</span><span class="line">def notify_site(problem_type, page_id, domain, email, url, page_type)
</span><span class="line">  email ||= "No Admin &lt;chssweb@gmu.edu&gt;"
</span><span class="line">  if @emaillist.has_key?(email)
</span><span class="line">    @emaillist[email] += ["On #{domain}/#{page_type}/#{page_id} the link #{url} is returning a #{problem_type}."]
</span><span class="line">  else
</span><span class="line">    @emaillist[email] = ["On #{domain}/#{page_type}/#{page_id} the link #{url} is returning a #{problem_type}."]
</span><span class="line">  end
</span><span class="line">  @logfile.puts("There was a #{problem_type} on #{domain}/#{page_type}/#{page_id} linking to #{url} and #{email} was notified.")
</span><span class="line">end
</span><span class="line">
</span><span class="line">def find_broken_link(original_site, id, admin_email, url, page_type)
</span><span class="line">  baseurl = organize_url(url, original_site)
</span><span class="line">  begin
</span><span class="line">    res = Net::HTTP.get_response(URI.parse(baseurl))
</span><span class="line">    puts "Code: #{res.code} for #{url}"
</span><span class="line">    notify_site("404 error", id, original_site, admin_email, url, page_type) if (res.code.to_i == 404)
</span><span class="line">  rescue
</span><span class="line">    puts "Broken/bad link for #{url}"
</span><span class="line">    notify_site("broken link error", id, original_site, admin_email, url, page_type)
</span><span class="line">  end
</span><span class="line">end
</span><span class="line">
</span><span class="line">def release_the_dogs(admin_contact, contact_message)
</span><span class="line">  BrokenLinkMailer.broken_link_notifier(admin_contact, contact_message).deliver
</span><span class="line">end
</span><span class="line">
</span><span class="line">@emaillist.each_key do |key|
</span><span class="line">  release_the_dogs(key, @emaillist[key])
</span><span class="line">end
</span><span class="line">
</span><span class="line">@events.each do |e|
</span><span class="line">  if e.url?
</span><span class="line">    find_broken_link(e.originating_site.domain,e.id, e.originating_site.reporting_email,e.url,"events")
</span><span class="line">  end
</span><span class="line">  long_desc_links = URI.extract(e.long_description).select!{|v| v =~ /http/}
</span><span class="line">  if !long_desc_links.blank?
</span><span class="line">    long_desc_links.each do |link|
</span><span class="line">      find_broken_link(e.originating_site.domain,e.id, e.originating_site.reporting_email,link,"events")
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end
</span><span class="line">
</span><span class="line">@articles.each do |a|
</span><span class="line">  if a.url_link?
</span><span class="line">    find_broken_link(a.originating_site.domain,a.id, a.originating_site.reporting_email,a.url_link,"articles")
</span><span class="line">  end
</span><span class="line">  long_desc_links = URI.extract(a.main_content).select!{|v| v =~ /http/}
</span><span class="line">  if !long_desc_links.blank?
</span><span class="line">    long_desc_links.each do |link|
</span><span class="line">      find_broken_link(a.originating_site.domain,a.id, a.originating_site.reporting_email,link,"articles")
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">
</span><span class="line">end
</span><span class="line">
</span><span class="line">@resources.each do |r|
</span><span class="line">  if r.page_id?
</span><span class="line">    if r.url?
</span><span class="line">      find_broken_link(r.originating_site.domain,r.id, r.originating_site.reporting_email,r.url,"resources")
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end
</span><span class="line">
</span><span class="line">@emaillist.each_key do |key|
</span><span class="line">  release_the_dogs(key, @emaillist[key])
</span><span class="line">end
</span><span class="line">
</span><span class="line">@logfile.close</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Starting with the low hanging fruit:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">  @events = Event.all
</span><span class="line">  @articles = Article.all
</span><span class="line">  @resources = Resource.all
</span><span class="line">.
</span><span class="line">.
</span><span class="line">.
</span><span class="line">  @events.each do |e|
</span><span class="line">    if e.url?
</span><span class="line">      find_broken_link(e.originating_site.domain,e.id, e.originating_site.reporting_email,e.url,"events")
</span><span class="line">    end
</span><span class="line">    long_desc_links = URI.extract(e.long_description).select!{|v| v =~ /http/}
</span><span class="line">    if !long_desc_links.blank?
</span><span class="line">      long_desc_links.each do |link|
</span><span class="line">        find_broken_link(e.originating_site.domain,e.id, e.originating_site.reporting_email,link,"events")
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">
</span><span class="line">  @articles.each do |a|
</span><span class="line">    if a.url_link?
</span><span class="line">      find_broken_link(a.originating_site.domain,a.id, a.originating_site.reporting_email,a.url_link,"articles")
</span><span class="line">    end
</span><span class="line">    long_desc_links = URI.extract(a.main_content).select!{|v| v =~ /http/}
</span><span class="line">    if !long_desc_links.blank?
</span><span class="line">      long_desc_links.each do |link|
</span><span class="line">        find_broken_link(a.originating_site.domain,a.id, a.originating_site.reporting_email,link,"articles")
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">
</span><span class="line">  end
</span><span class="line">
</span><span class="line">  @resources.each do |r|
</span><span class="line">    if r.page_id?
</span><span class="line">      if r.url?
</span><span class="line">        find_broken_link(r.originating_site.domain,r.id, r.originating_site.reporting_email,r.url,"resources")
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">`
</span><span class="line">
</span><span class="line">I started by creating a scope in resources that checks for a `page_id` and a `url`. I also created some aliases for `url_link` and `main_content` to in my `Article` model in order to have parity with the `Event` and `Resource` model in order to get some uniformity.
</span><span class="line">
</span><span class="line">`
</span><span class="line">@events = Event.unlinked_events
</span><span class="line">@event_links = Event.linked_events
</span><span class="line">@articles = Article.unlinked_articles
</span><span class="line">@article_links = Article.linked_articles
</span><span class="line">@resources = Resource.link_resources
</span><span class="line">
</span><span class="line">[@event_links, @article_links, @resources].each do |collection_item|
</span><span class="line">  collection_item.each do |item|
</span><span class="line">    find_broken_link(item.originating_site.domain,item.id,
</span><span class="line">                               item.originating_site.reporting_email,
</span><span class="line">                               item.url,item.class.name.downcase.pluralize)
</span><span class="line">  end
</span><span class="line">end
</span><span class="line">
</span><span class="line">[@events, @articles].each do |collection_item|
</span><span class="line">  collection_item.each do |item|
</span><span class="line">    long_desc_links = URI.extract(item.long_description).select!{|v| v =~ /http/}
</span><span class="line">    unless long_desc_links.blank?
</span><span class="line">      long_desc_links.each do |link|
</span><span class="line">        find_broken_link(item.originating_site.domain,item.id,
</span><span class="line">                                   item.originating_site.reporting_email,
</span><span class="line">                                   link,item.class.name.downcase.pluralize)
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Was passing too much stuff into <code>find_broken_link</code> so that was decomposed.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">[@event_links, @article_links, @resources].each do |collection_item|
</span><span class="line">  collection_item.each do |item|
</span><span class="line">    find_broken_link(link_details(item))
</span><span class="line">  end
</span><span class="line">end
</span><span class="line">
</span><span class="line">[@events, @articles].each do |collection_item|
</span><span class="line">  collection_item.each do |item|
</span><span class="line">    long_desc_links = URI.extract(item.long_description).select!{|v| v =~ /http/}
</span><span class="line">    unless long_desc_links.blank?
</span><span class="line">      long_desc_links.each do |link|
</span><span class="line">        find_broken_link(link_details(item, link))
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end
</span><span class="line">
</span><span class="line">#method for cleaning up the passed in stuff called inside find_broken_link:
</span><span class="line">
</span><span class="line">def link_details(link_item, link = nil)
</span><span class="line">  {
</span><span class="line">    :original_site =&gt; link_item.originating_site.domain,
</span><span class="line">    :id =&gt; link_item.id,
</span><span class="line">    :admin_email =&gt; link_item.originating_site.reporting_email,
</span><span class="line">    :url =&gt; link.nil? ? link_item.url : link,
</span><span class="line">    :page_type =&gt; link_item.class.name.downcase.pluralize
</span><span class="line">  }
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Nothing here really sped the task up so that was the next part. I next implemented Celluloid and broke this up into three files.</p>

<p>Lots of instance variables:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">#checker.rb
</span><span class="line">require 'celluloid/autostart'
</span><span class="line">require 'logger'
</span><span class="line">require_relative 'broken_link/link_cell'
</span><span class="line">require_relative 'broken_link/link_checker'
</span><span class="line">
</span><span class="line">module Checker
</span><span class="line">  DEFAULTS = {
</span><span class="line">    default_protocol:   'http://',
</span><span class="line">    pool_size:          25,
</span><span class="line">    logger_class:       Logger,
</span><span class="line">    admin_email:        "No Admin &lt;chssweb@gmu.edu&gt;",
</span><span class="line">    log_file_name:      "bad_link_log.csv"
</span><span class="line">  }
</span><span class="line">
</span><span class="line">  def self.linkcheck(opts={})
</span><span class="line">    link_check_results = LinkChecker.new(opts)
</span><span class="line">    link_check_results.agent_pool.future.terminate
</span><span class="line">
</span><span class="line">    link_check_results
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">module Checker
</span><span class="line">  class LinkChecker
</span><span class="line">    attr_reader :agent_pool, :opts, :default_protocol, :output_file, :logger
</span><span class="line">
</span><span class="line">    def initialize(override_opts={})
</span><span class="line">      @opts  = DEFAULTS.merge(override_opts)
</span><span class="line">      @default_protocol = opts[:default_protocol]
</span><span class="line">      @output_file = opts[:output_file] || File.open(opts[:log_file_name], 'a')
</span><span class="line">      @logger = opts[:logger_class].new(output_file)
</span><span class="line">      @agent_pool = LinkCell.pool(size: opts[:pool_size], args: [logger])
</span><span class="line">      @events = Event.unlinked_events
</span><span class="line">      @event_links = Event.linked_events
</span><span class="line">      @articles = Article.unlinked_articles
</span><span class="line">      @article_links = Article.linked_articles
</span><span class="line">      @resources = Resource.linkable
</span><span class="line">      @count = 0
</span><span class="line">      check_embedded_links
</span><span class="line">      check_direct_links
</span><span class="line">      self
</span><span class="line">    ensure
</span><span class="line">      output_file.close if output_file.respond_to?(:close)
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def check_direct_links
</span><span class="line">      [@event_links, @article_links, @resources].each do |collection_item|
</span><span class="line">        collection_item.each do |item|
</span><span class="line">          find_broken_link(link_details(item))
</span><span class="line">        end
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def check_embedded_links
</span><span class="line">      [@events, @articles].each do |collection_item|
</span><span class="line">        collection_item.each do |item|
</span><span class="line">          long_desc_links = URI.extract(item.long_description).select!{|v| v =~ /http/}
</span><span class="line">          unless long_desc_links.blank?
</span><span class="line">            long_desc_links.each do |link|
</span><span class="line">              find_broken_link(link_details(item, link))
</span><span class="line">            end
</span><span class="line">          end
</span><span class="line">        end
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    private
</span><span class="line">
</span><span class="line">    def link_details(link_item, link = nil)
</span><span class="line">      {
</span><span class="line">        :original_site =&gt; link_item.originating_site.domain,
</span><span class="line">        :id =&gt; link_item.id,
</span><span class="line">        :admin_email =&gt; link_item.originating_site.reporting_email.empty? ? "No Admin &lt;chssweb@gmu.edu&gt;" : link_item.originating_site.reporting_email,
</span><span class="line">        :url =&gt; link.nil? ? link_item.url : link,
</span><span class="line">        :page_type =&gt; link_item.class.name.downcase.pluralize
</span><span class="line">      }
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def find_broken_link(url)
</span><span class="line">      agent_pool.future.get(url)
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">module Checker
</span><span class="line">  class LinkCell
</span><span class="line">    include Celluloid
</span><span class="line">
</span><span class="line">    attr_reader :logger
</span><span class="line">
</span><span class="line">    def initialize(logger)
</span><span class="line">      @logger = logger
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def organize_url(url, originating_site_domain)
</span><span class="line">      url.insert(0, originating_site_domain) if url.match(/^\//)
</span><span class="line">      url.insert(0, "http://") unless (((url.match(/^http\:\/\//)) or (url.match(/^https\:\/\//))) || url.empty?)
</span><span class="line">      url = URI.encode(url) if (url =~ URI::DEFAULT_PARSER.regexp[:ABS_URI]).nil?
</span><span class="line">      return url
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def get(link)
</span><span class="line">      site = link[:original_site]
</span><span class="line">      return if organize_url(link[:url],site).empty?
</span><span class="line">      baseurl = organize_url(link[:url],site)
</span><span class="line">      begin
</span><span class="line">        res = Net::HTTP.get_response(URI.parse(baseurl))
</span><span class="line">        puts "Code: #{res.code} for #{link[:url]}"
</span><span class="line">        logger &lt;&lt; "404 error, #{link[:id]}, #{link[:original_site]}, \
</span><span class="line">                  #{link[:admin_email]}, #{link[:url]}, #{link[:page_type]}\n" if (res.code.to_i == 404)
</span><span class="line">      rescue
</span><span class="line">        puts "Broken/bad link for #{link[:url]}"
</span><span class="line">        logger &lt;&lt; "Broken link error, #{link[:id]}, #{link[:original_site]}, \
</span><span class="line">                  #{link[:admin_email]}, #{link[:url]}, #{link[:page_type]}\n"
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>I’m still on the fence on <code>DEFAULTS</code> option has I pass in. I realize it is probably better OO to do it that way and it makes it better for customizing and changing in the future but I fell that right now it is just wasting space.</p>

<p>So after cleaning up all those ugly instance variables:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">#link_checker.rb
</span><span class="line">module Checker
</span><span class="line">  class LinkChecker
</span><span class="line">    attr_reader :agent_pool, :direct_links, :embedded_links, :logger, :opts, :output_file
</span><span class="line">
</span><span class="line">    def initialize(override_opts={})
</span><span class="line">      @opts  = DEFAULTS.merge(override_opts)
</span><span class="line">      @output_file = opts[:output_file] || File.open(opts[:log_file_name], 'a')
</span><span class="line">      @logger = opts[:logger_class].new(output_file)
</span><span class="line">      @agent_pool = LinkCell.pool(size: opts[:pool_size], args: [logger])
</span><span class="line">      @embedded_links = Event.unlinked_events + Article.unlinked_articles
</span><span class="line">      @direct_links = Event.linked_events + Article.linked_articles + Resource.linkable
</span><span class="line">      check_embedded_links
</span><span class="line">      check_direct_links
</span><span class="line">      self
</span><span class="line">    ensure
</span><span class="line">      output_file.close if output_file.respond_to?(:close)
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def check_direct_links
</span><span class="line">      direct_links.each do |item|
</span><span class="line">        find_broken_link(link_details(item))
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def check_embedded_links
</span><span class="line">      embedded_links.each do |item|
</span><span class="line">        long_desc_links = URI.extract(item.long_description).select!{|v| v =~ /http/}
</span><span class="line">        unless long_desc_links.blank?
</span><span class="line">          long_desc_links.each do |link|
</span><span class="line">            find_broken_link(link_details(item, link))
</span><span class="line">          end
</span><span class="line">        end
</span><span class="line">      end
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def link_details(link_item, link = nil)
</span><span class="line">      {
</span><span class="line">        :original_site =&gt; link_item.originating_site.domain,
</span><span class="line">        :id =&gt; link_item.id,
</span><span class="line">        :admin_email =&gt; link_item.originating_site.reporting_email.empty? ? "No Admin &lt;chssweb@gmu.edu&gt;" : link_item.originating_site.reporting_email,
</span><span class="line">        :url =&gt; link.nil? ? link_item.url : link,
</span><span class="line">        :page_type =&gt; link_item.class.name.downcase.pluralize,
</span><span class="line">        :originating_site =&gt; link_item.originating_site.id
</span><span class="line">      }
</span><span class="line">    end
</span><span class="line">
</span><span class="line">    def find_broken_link(url)
</span><span class="line">      agent_pool.future.get(url)
</span><span class="line">    end
</span><span class="line">  end
</span><span class="line">end
</span><span class="line">###</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>I wanted to start fresh with a new log each time so:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="code"><pre><code class=""><span class="line">require 'celluloid/autostart'
</span><span class="line">require 'logger'
</span><span class="line">require_relative 'broken_link/link_cell'
</span><span class="line">require_relative 'broken_link/link_checker'
</span><span class="line">
</span><span class="line">module Checker
</span><span class="line">  DEFAULTS = {
</span><span class="line">    pool_size:          25,
</span><span class="line">    logger_class:       Logger,
</span><span class="line">    admin_email:        "No Admin &lt;chssweb@gmu.edu&gt;",
</span><span class="line">    log_file_name:      "bad_link_log.csv"
</span><span class="line">  }
</span><span class="line">
</span><span class="line">  def self.linkcheck(opts={})
</span><span class="line">    File.delete("bad_link_log.csv") if File.exist?("bad_link_log.csv")
</span><span class="line">    link_check_results = LinkChecker.new(opts)
</span><span class="line">    link_check_results.agent_pool.future.terminate
</span><span class="line">
</span><span class="line">    link_check_results
</span><span class="line">  end
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>No updates yet on the <code>link_cell.rb</code> file but this has greatly improved the speed of the task. What was a ~35 minute task now runs in about a minute.</p>

<p>More refactorings on this to come…</p>
]]></content>
  </entry>
  
</feed>
